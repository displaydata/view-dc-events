input {
    pipeline {
        address => "communicator-state"
    }
}
# Dynamic Central User Events
#
# Timestamp: time that the event actually occured
# @t : Time the event was processed by Dynanic Central Status Monitor
# @timestamp: Time that the event was ingested into elasticsearch
filter {
    json {
        source => "message"
        skip_on_invalid_json => true
        remove_field => [ "@mt" ]
    }

    # We're only interested in CommunicatorStateChange events so drop everything else
    if [MessageType] != "CommunicatorStateChange" {
        drop { }
    }

    # remove un-necessary fields before indexing
    mutate { 
        remove_field => [ "message", "host" ]
    }
}
output {
    elasticsearch {
        hosts => ["${HOSTS:elasticsearch:9200}"]
        user => "${LOGSTASH_USER:elastic}"
        password => "${LOGSTASH_PASSWORD:elastic}"
        index => "dynamic-communicator-state"
        document_id => "%{CommunicatorSerialNumber}"
        action => update
        doc_as_upsert => true
        script => "Instant stored_change_time = Instant.parse(ctx._source.Timestamp); Instant new_change_time = Instant.parse(params.event.Timestamp); if (new_change_time.isBefore(stored_change_time)) { ctx.op = 'none'; return; } def previousState = ctx._source.Result; def newState = params.event.Result; if (previousState == 'CommunicatorConnected' && newState != 'CommunicatorConnected') { ctx._source.disconnectedTimestamp = params.event.Timestamp; } else if (newState == 'CommunicatorConnected') { ctx._source.disconnectedTimestamp = null; } for (entry in params.event.entrySet()) { def key = entry.getKey(); ctx._source[key] = entry.getValue(); }"
    }
}
