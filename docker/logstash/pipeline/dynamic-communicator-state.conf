input {
    pipeline {
        address => "communicator-state"
    }
}
# Dynamic Central User Events
#
# Timestamp: time that the event actually occured
# @t : Time the event was processed by Dynanic Central Status Monitor
# @timestamp: Time that the event was ingested into elasticsearch
filter {
    json {
        source => "message"
        skip_on_invalid_json => true
        remove_field => [ "@mt" ]
    }

    # We're only interested in CommunicatorStateChange events so drop everything else
    if [MessageType] != "CommunicatorStateChange" {
        drop { }
    }
    # format field as a date object so it can be succesfully parsed by the Ruby code below
    date {
        match => ["Timestamp", "ISO8601"]
        target => "date_object"
    }
    # create a new field recording the last time the communicator connected successfully
    if [Result] == "CommunicatorConnected" {
        mutate {
            add_field => {
                "LastConnectedTimestamp" => "%{Timestamp}"
            }
        }
    }
    # remove un-necessary fields before indexing
    mutate { 
        remove_field => [ "message", "host" ]
    }
}
output {
    elasticsearch {
        hosts => ["elasticsearch:9200"]
        user => elastic
        password => elastic
        index => "dynamic-communicator-state"
        document_id => "%{CommunicatorSerialNumber}"
        action => update
        doc_as_upsert => true
        script => "Instant stored_change_time = Instant.parse(ctx._source[Timestamp]); Instant new_change_time = Instant.parse(params.event[Timestamp]); if (new_change_time.isBefore(stored_change_time)) { ctx.op = 'none'; return; }"
    }
}