{
  "trigger": {
    "schedule": {
      "interval": "60m"
    }
  },
  "input": {
    "chain": {
      "inputs": [
        {
          "first": {
            "search": {
              "request": {
                "search_type": "query_then_fetch",
                "indices": [
                  "dynamic-communicator-state"
                ],
                "rest_total_hits_as_int": true,
                "body": {
                  "query": {
                    "bool": {
                      "must": [
                        {
                          "exists": {
                            "field": "disconnectedTimestamp"
                          }
                        },
                        {
                          "range": {
                            "disconnectedTimestamp": {
                              "lte": "now-30m"
                            }
                          }
                        }
                      ]
                    }
                  }
                }
              }
            }
          }
        },
        {
          "first_transform": {
            "transform": {
              "script": {
                "source": "\n                    def mustache_serial_numbers = ctx.payload.first.hits.hits.stream()\n                            .map(h -> { return ['value': h._source.CommunicatorSerialNumber, 'first': false ] })\n                            .collect(Collectors.toList());\n                            \n                    if (mustache_serial_numbers.size() > 0) {\n                        mustache_serial_numbers[0].first = true;\n                    }        \n\n                    return [\n                        'serial_numbers': mustache_serial_numbers\n                    ];\n                ",
                "lang": "painless"
              }
            }
          }
        },
        {
          "second": {
            "search": {
              "request": {
                "search_type": "query_then_fetch",
                "indices": [
                  "openvpnremote-communicators"
                ],
                "rest_total_hits_as_int": true,
                "body": {
                  "query": {
                    "ids": {
                      "values": [
                        "{{#ctx.payload.first_transform.serial_numbers}}{{^first}}",
                        "{{/first}}{{value}}{{/ctx.payload.first_transform.serial_numbers}}"
                      ]
                    }
                  }
                }
              }
            }
          }
        }
      ]
    }
  },
  "condition": {
    "compare": {
      "ctx.payload.first.hits.total": {
        "gte": 1
      }
    }
  },
  "actions": {
    "send_email": {
      "foreach": "ctx.payload.merged",
      "max_iterations": 100,
      "email": {
        "profile": "standard",
        "to": [
          "support@displaydata.com"
        ],
        "subject": "Alert: communicator {{ ctx.payload.dynamic_central.CommunicatorSerialNumber }} offline",
        "body": {
          "text": "Communicator offline:\n  * Serial number: {{ ctx.payload.dynamic_central.CommunicatorSerialNumber }}\n  * Location name: {{ ctx.payload.dynamic_central.LocationName }}\n * Disconnected: {{ ctx.payload.dynamic_central.disconnectedTimestamp }}\n \nOpenVPN status:\n    {{ ctx.payload.openvpn }}\n"
        }
      }
    }
  },
  "transform": {
    "script": {
      "source": "\n        def openVpnStatuses = ctx.payload.second.hits.hits.stream()\n          .collect(Collectors.toMap(h -> h._id, h -> h._source));\n        \n        def merged = ctx.payload.first.hits.hits.stream()\n          .map(h -> [ 'dynamic_central': h._source, 'openvpn': openVpnStatuses.get(h._source.CommunicatorSerialNumber) ])\n          .collect(Collectors.toList());\n          \n        return [ 'merged': merged ]\n    ",
      "lang": "painless"
    }
  },
  "metadata": {
    "xpack": {
      "type": "json"
    },
    "name": "communicator_openvpn_alert"
  },
  "enabled": false
}
